2020-10-29T21:19:19.488+0800: 114.015: [GC (CMS Initial Mark) [1 CMS-initial-mark: 106000K(2097152K)] 1084619K(3984640K), 0.2824583 secs] [Times: user=0.86 sys=0.00, real=0.28 secs]
## cms 表示这是CMS开始对老年代进行垃圾收集的初始标记,该阶段从垃圾回收的"跟对象开始",且只扫描直接与"跟对象"直接关联的对象,并做标记,需要暂停用户线程,（Stop The Word，下面统称为STW），
速度很快。106000K(2097152K)表示当前老年代的容量为126116K，在使用了106000K时开始进行CMS垃圾回收。可以计算下这个比例，106000K /2097152K约等于0.05，可以大概推算出CMS收集器的启动内存使用阈值。
后面的1084619K(3984640K), 0.2824583 secs表示当前整个堆的内存使用情况和本次初始标记耗费的时间

2020-10-29T21:19:19.771+0800: 114.298: [CMS-concurrent-mark-start]
## cms  并发标记
2020-10-29T21:19:19.931+0800: 114.458: [CMS-concurrent-mark: 0.160/0.160 secs] [Times: user=0.32 sys=0.03, real=0.16 secs]
## cms 并发标记阶段,会遍历整个老年代并且标记活着的对象
GC事件在不同维度的耗时，单位为秒   user、sys和real与Linux的time命令所输出的时间含义一致,分别表示用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的等待耗时，
例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以有时候user或sys时间超过real时间也是完全正确的。
cms 并发标记,用户标记时间0.32s, 内核态消耗的CPU时间0.03s,操作从开始到结束等待耗时0.16s

2020-10-29T21:19:19.931+0800: 114.459: [CMS-concurrent-preclean-start]
## cms  并发预清理

2020-10-29T21:19:19.998+0800: 114.525: [CMS-concurrent-preclean: 0.065/0.066 secs] [Times: user=0.05 sys=0.01, real=0.06 secs]
## cms 并发预清理,阶段会把上一个阶段被标记为Dirty Card的对象以及可达的对象重新遍历标记，完成后清楚Dirty Card标记。
另外，一些必要的清扫工作也会做，还会做一些final remark阶段需要的准备工作。
用户标记时间0.05s, 内核态消耗的CPU时间0.01s,操作从开始到结束等待耗时0.06s


2020-10-29T21:19:19.998+0800: 114.525: [CMS-concurrent-abortable-preclean-start]CMS: abort preclean due to time
## cms 并发预清理这个阶段尝试去承担接下来STW的Final Remark 阶段足够多的工作,由于这个阶段是重复做着相同的事情直到发生rebort的条件
（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。这个阶段很大程度的影响着即将来临的Final Remark的停顿。
用户标记时间0.05s, 内核态消耗的CPU时间0.01s,操作从开始到结束等待耗时0.06s

2020-10-29T21:19:25.072+0800: 119.599: [CMS-concurrent-abortable-preclean: 5.038/5.073 secs] [Times: user=7.72 sys=0.50, real=5.08 secs]
2020-10-29T21:19:25.076+0800: 119.603: [GC (CMS Final Remark) [YG occupancy: 1279357 K (1887488 K)]
## cms 最终标记,GC事件中的第二次标记,（也是最后一次）STW停顿。本阶段的目标是完后才能老年代所有存活的标记。因为之前的预处理阶段都是并发标记的,有可能GC线程
跟不上应用程序的修改速度。[YG occupancy: 1279357 K (1887488 K)]表示年轻代当前的内存占用情况，
通常Final Remark阶段要尽量运行在年轻代是足够干净的时候，这样可以消除紧接着的连续的几个STW阶段。

2020-10-29T21:19:25.076+0800: 119.603: [Rescan (parallel) , 0.3120602 secs]
## 整个final remark阶段扫描对象的用时总计,该阶段会重新扫描CMS堆中剩余的对象,重新从跟对象开始扫描，并且处理对象关联

2020-10-29T21:19:25.388+0800: 119.915: [weak refs processing, 0.0015920 secs]
## 第一个子阶段，表示对弱引用的处理耗时0015920

2020-10-29T21:19:25.390+0800: 119.917: [class unloading, 0.0517863 secs]
## 第二个子阶段 表示卸载无用类的耗时 0.0517863

2020-10-29T21:19:25.441+0800: 119.969: [scrub symbol table, 0.0212825 secs]
## 最后一个子阶段 表示清理分别包含类级元素和内部化字符串的符号,和字符串表的耗时

2020-10-29T21:19:25.463+0800: 119.990: [scrub string table, 0.0022435 secs][1 CMS-remark: 106000K(2097152K)] 1385358K(3984640K), 0.3959182 secs] [Times: user=1.33 sys=0.00, real=0.40 secs]
## 最后一个子阶段 表示清理分别包含类级元素和内部化字符串的符号,和字符串表的耗时

2020-10-29T21:19:25.473+0800: 120.000: [CMS-concurrent-sweep-start]
## cms并发清除阶段开始

2020-10-29T21:19:25.540+0800: 120.067: [CMS-concurrent-sweep: 0.067/0.067 secs] [Times: user=0.18 sys=0.02, real=0.06 secs]
## 第一个子阶段,任务清除那些没有标记的无用对象并回收内存。

2020-10-29T21:19:25.540+0800: 120.068: [CMS-concurrent-reset-start]
## 第二个阶段,作用是重新设置CMS算法内部结构,准备下一个CMS生命周期的使用

2020-10-29T21:19:25.544+0800: 120.071: [CMS-concurrent-reset: 0.003/0.003 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]